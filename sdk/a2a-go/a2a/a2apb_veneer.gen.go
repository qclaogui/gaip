// Copyright Â© Weifeng Wang <qclaogui@gmail.com>
//
// Licensed under the Apache License 2.0.

// Copyright 2024 Weifeng Wang <qclaogui@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file was generated by protoveneer. DO NOT EDIT.

package a2a

import (
	"fmt"
	"time"

	pb "github.com/qclaogui/gaip/genproto/a2a/apiv1/a2apb"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type APIKeySecurityScheme struct {
	// Description of this security scheme.
	Description string
	// Location of the API key, valid values are "query", "header", or "cookie"
	Location string
	// Name of the header, query or cookie parameter to be used.
	Name string
}

func (v *APIKeySecurityScheme) toProto() *pb.APIKeySecurityScheme {
	if v == nil {
		return nil
	}
	return &pb.APIKeySecurityScheme{
		Description: v.Description,
		Location:    v.Location,
		Name:        v.Name,
	}
}

func (APIKeySecurityScheme) fromProto(p *pb.APIKeySecurityScheme) *APIKeySecurityScheme {
	if p == nil {
		return nil
	}
	return &APIKeySecurityScheme{
		Description: p.Description,
		Location:    p.Location,
		Name:        p.Name,
	}
}

// AgentCapabilities is defines the A2A feature set supported by the agent
type AgentCapabilities struct {
	// If the agent will support streaming responses
	Streaming bool
	// If the agent can send push notifications to the clients webhook
	PushNotifications bool
	// Extensions supported by this agent.
	Extensions []*AgentExtension
}

func (v *AgentCapabilities) toProto() *pb.AgentCapabilities {
	if v == nil {
		return nil
	}
	return &pb.AgentCapabilities{
		Streaming:         v.Streaming,
		PushNotifications: v.PushNotifications,
		Extensions:        pvTransformSlice(v.Extensions, (*AgentExtension).toProto),
	}
}

func (AgentCapabilities) fromProto(p *pb.AgentCapabilities) *AgentCapabilities {
	if p == nil {
		return nil
	}
	return &AgentCapabilities{
		Streaming:         p.Streaming,
		PushNotifications: p.PushNotifications,
		Extensions:        pvTransformSlice(p.Extensions, (AgentExtension{}).fromProto),
	}
}

// AgentCard conveys key information:
// - Overall details (version, name, description, uses)
// - Skills; a set of actions/solutions the agent can perform
// - Default modalities/content types supported by the agent.
// - Authentication requirements
type AgentCard struct {
	// The version of the A2A protocol this agent supports.
	ProtocolVersion string
	// A human readable name for the agent.
	// Example: "Recipe Agent"
	Name string
	// A description of the agent's domain of action/solution space.
	// Example: "Agent that helps users with recipes and cooking."
	Description string
	// The base url to interact with the agent at.
	Url string
	// The transport of the preferred endpoint. If empty, defaults to JSONRPC.
	PreferredTransport string
	// Announcement of additional supported transports. Client can use any of
	// the supported transports.
	AdditionalInterfaces []*AgentInterface
	// The service provider of the agent.
	Provider *AgentProvider
	// The version of the agent.
	// Example: "1.0.0"
	Version string
	// A url to provide additional documentation about the agent.
	DocumentationUrl string
	// A2A Capability set supported by the agent.
	Capabilities *AgentCapabilities
	// The security scheme details used for authenticating with this agent.
	SecuritySchemes map[string]SecurityScheme
	// Security requirements for contacting the agent.
	Security []*Security
	// The set of interaction modes that the agent supports across all skills.
	// This can be overridden per skill. Defined as mime types.
	DefaultInputModes []string
	// The mime types supported as outputs from this agent.
	DefaultOutputModes []string
	// Skills represent a unit of ability an agent can perform. This may
	// somewhat abstract but represents a more focused set of actions that the
	// agent is highly likely to succeed at.
	Skills []*AgentSkill
	// Whether the agent supports providing an extended agent card when
	// the user is authenticated, i.e. is the card from .well-known
	// different than the card from GetAgentCard.
	SupportsAuthenticatedExtendedCard bool
}

func (v *AgentCard) toProto() *pb.AgentCard {
	if v == nil {
		return nil
	}
	return &pb.AgentCard{
		ProtocolVersion:                   v.ProtocolVersion,
		Name:                              v.Name,
		Description:                       v.Description,
		Url:                               v.Url,
		PreferredTransport:                v.PreferredTransport,
		AdditionalInterfaces:              pvTransformSlice(v.AdditionalInterfaces, (*AgentInterface).toProto),
		Provider:                          v.Provider.toProto(),
		Version:                           v.Version,
		DocumentationUrl:                  v.DocumentationUrl,
		Capabilities:                      v.Capabilities.toProto(),
		SecuritySchemes:                   pvTransformMapValues(v.SecuritySchemes, securitySchemeToProto),
		Security:                          pvTransformSlice(v.Security, (*Security).toProto),
		DefaultInputModes:                 v.DefaultInputModes,
		DefaultOutputModes:                v.DefaultOutputModes,
		Skills:                            pvTransformSlice(v.Skills, (*AgentSkill).toProto),
		SupportsAuthenticatedExtendedCard: v.SupportsAuthenticatedExtendedCard,
	}
}

func (AgentCard) fromProto(p *pb.AgentCard) *AgentCard {
	if p == nil {
		return nil
	}
	return &AgentCard{
		ProtocolVersion:                   p.ProtocolVersion,
		Name:                              p.Name,
		Description:                       p.Description,
		Url:                               p.Url,
		PreferredTransport:                p.PreferredTransport,
		AdditionalInterfaces:              pvTransformSlice(p.AdditionalInterfaces, (AgentInterface{}).fromProto),
		Provider:                          (AgentProvider{}).fromProto(p.Provider),
		Version:                           p.Version,
		DocumentationUrl:                  p.DocumentationUrl,
		Capabilities:                      (AgentCapabilities{}).fromProto(p.Capabilities),
		SecuritySchemes:                   pvTransformMapValues(p.SecuritySchemes, securitySchemeFromProto),
		Security:                          pvTransformSlice(p.Security, (Security{}).fromProto),
		DefaultInputModes:                 p.DefaultInputModes,
		DefaultOutputModes:                p.DefaultOutputModes,
		Skills:                            pvTransformSlice(p.Skills, (AgentSkill{}).fromProto),
		SupportsAuthenticatedExtendedCard: p.SupportsAuthenticatedExtendedCard,
	}
}

// AgentExtension is a declaration of an extension supported by an Agent.
type AgentExtension struct {
	// The URI of the extension.
	// Example: "https://developers.google.com/identity/protocols/oauth2"
	Uri string
	// A description of how this agent uses this extension.
	// Example: "Google OAuth 2.0 authentication"
	Description string
	// Whether the client must follow specific requirements of the extension.
	// Example: false
	Required bool
	// Optional configuration for the extension.
	Params map[string]any
}

func (v *AgentExtension) toProto() *pb.AgentExtension {
	if v == nil {
		return nil
	}
	return &pb.AgentExtension{
		Uri:         v.Uri,
		Description: v.Description,
		Required:    v.Required,
		Params:      pvMapToStructPB(v.Params),
	}
}

func (AgentExtension) fromProto(p *pb.AgentExtension) *AgentExtension {
	if p == nil {
		return nil
	}
	return &AgentExtension{
		Uri:         p.Uri,
		Description: p.Description,
		Required:    p.Required,
		Params:      pvMapFromStructPB(p.Params),
	}
}

// AgentInterface is defines additional transport information for the agent.
type AgentInterface struct {
	// The url this interface is found at.
	Url string
	// The transport supported this url. This is an open form string, to be
	// easily extended for many transport protocols. The core ones officially
	// supported are JSONRPC, GRPC and HTTP+JSON.
	Transport string
}

func (v *AgentInterface) toProto() *pb.AgentInterface {
	if v == nil {
		return nil
	}
	return &pb.AgentInterface{
		Url:       v.Url,
		Transport: v.Transport,
	}
}

func (AgentInterface) fromProto(p *pb.AgentInterface) *AgentInterface {
	if p == nil {
		return nil
	}
	return &AgentInterface{
		Url:       p.Url,
		Transport: p.Transport,
	}
}

// AgentProvider is represents information about the service provider of an agent.
type AgentProvider struct {
	// The providers reference url
	// Example: "https://ai.google.dev"
	Url string
	// The providers organization name
	// Example: "Google"
	Organization string
}

func (v *AgentProvider) toProto() *pb.AgentProvider {
	if v == nil {
		return nil
	}
	return &pb.AgentProvider{
		Url:          v.Url,
		Organization: v.Organization,
	}
}

func (AgentProvider) fromProto(p *pb.AgentProvider) *AgentProvider {
	if p == nil {
		return nil
	}
	return &AgentProvider{
		Url:          p.Url,
		Organization: p.Organization,
	}
}

// AgentSkill represents a unit of action/solution that the agent can perform.
// One can think of this as a type of highly reliable solution that an agent
// can be tasked to provide. Agents have the autonomy to choose how and when
// to use specific skills, but clients should have confidence that if the
// skill is defined that unit of action can be reliably performed.
type AgentSkill struct {
	// Unique id of the skill within this agent.
	Id string
	// A human readable name for the skill.
	Name string
	// A human (or llm) readable description of the skill
	// details and behaviors.
	Description string
	// A set of tags for the skill to enhance categorization/utilization.
	// Example: ["cooking", "customer support", "billing"]
	Tags []string
	// A set of example queries that this skill is designed to address.
	// These examples should help the caller to understand how to craft requests
	// to the agent to achieve specific goals.
	// Example: ["I need a recipe for bread"]
	Examples []string
	// Possible input modalities supported.
	InputModes []string
	// Possible output modalities produced
	OutputModes []string
}

func (v *AgentSkill) toProto() *pb.AgentSkill {
	if v == nil {
		return nil
	}
	return &pb.AgentSkill{
		Id:          v.Id,
		Name:        v.Name,
		Description: v.Description,
		Tags:        v.Tags,
		Examples:    v.Examples,
		InputModes:  v.InputModes,
		OutputModes: v.OutputModes,
	}
}

func (AgentSkill) fromProto(p *pb.AgentSkill) *AgentSkill {
	if p == nil {
		return nil
	}
	return &AgentSkill{
		Id:          p.Id,
		Name:        p.Name,
		Description: p.Description,
		Tags:        p.Tags,
		Examples:    p.Examples,
		InputModes:  p.InputModes,
		OutputModes: p.OutputModes,
	}
}

// Artifact is artifacts are the container for task completed results. These are similar
// to Messages but are intended to be the product of a task, as opposed to
// point-to-point communication.
type Artifact struct {
	// Unique id for the artifact. It must be at least unique within a task.
	ArtifactId string
	// A human readable name for the artifact.
	Name string
	// A human readable description of the artifact, optional.
	Description string
	// The content of the artifact.
	Parts []Part
	// Optional metadata included with the artifact.
	Metadata map[string]any
	// The URIs of extensions that are present or contributed to this Artifact.
	Extensions []string
}

func (v *Artifact) toProto() *pb.Artifact {
	if v == nil {
		return nil
	}
	return &pb.Artifact{
		ArtifactId:  v.ArtifactId,
		Name:        v.Name,
		Description: v.Description,
		Parts:       pvTransformSlice(v.Parts, partToProto),
		Metadata:    pvMapToStructPB(v.Metadata),
		Extensions:  v.Extensions,
	}
}

func (Artifact) fromProto(p *pb.Artifact) *Artifact {
	if p == nil {
		return nil
	}
	return &Artifact{
		ArtifactId:  p.ArtifactId,
		Name:        p.Name,
		Description: p.Description,
		Parts:       pvTransformSlice(p.Parts, partFromProto),
		Metadata:    pvMapFromStructPB(p.Metadata),
		Extensions:  p.Extensions,
	}
}

// AuthenticationInfo is defines authentication details, used for push notifications.
type AuthenticationInfo struct {
	// Supported authentication schemes - e.g. Basic, Bearer, etc
	Schemes []string
	// Optional credentials
	Credentials string
}

func (v *AuthenticationInfo) toProto() *pb.AuthenticationInfo {
	if v == nil {
		return nil
	}
	return &pb.AuthenticationInfo{
		Schemes:     v.Schemes,
		Credentials: v.Credentials,
	}
}

func (AuthenticationInfo) fromProto(p *pb.AuthenticationInfo) *AuthenticationInfo {
	if p == nil {
		return nil
	}
	return &AuthenticationInfo{
		Schemes:     p.Schemes,
		Credentials: p.Credentials,
	}
}

type AuthorizationCodeOAuthFlow struct {
	// The authorization URL to be used for this flow. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS
	AuthorizationUrl string
	// The token URL to be used for this flow. This MUST be in the form of a URL.
	// The OAuth2 standard requires the use of TLS.
	TokenUrl string
	// The URL to be used for obtaining refresh tokens. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS.
	RefreshUrl string
	// The available scopes for the OAuth2 security scheme. A map between the
	// scope name and a short description for it. The map MAY be empty.
	Scopes map[string]string
}

func (v *AuthorizationCodeOAuthFlow) toProto() *pb.AuthorizationCodeOAuthFlow {
	if v == nil {
		return nil
	}
	return &pb.AuthorizationCodeOAuthFlow{
		AuthorizationUrl: v.AuthorizationUrl,
		TokenUrl:         v.TokenUrl,
		RefreshUrl:       v.RefreshUrl,
		Scopes:           v.Scopes,
	}
}

func (AuthorizationCodeOAuthFlow) fromProto(p *pb.AuthorizationCodeOAuthFlow) *AuthorizationCodeOAuthFlow {
	if p == nil {
		return nil
	}
	return &AuthorizationCodeOAuthFlow{
		AuthorizationUrl: p.AuthorizationUrl,
		TokenUrl:         p.TokenUrl,
		RefreshUrl:       p.RefreshUrl,
		Scopes:           p.Scopes,
	}
}

type ClientCredentialsOAuthFlow struct {
	// The token URL to be used for this flow. This MUST be in the form of a URL.
	// The OAuth2 standard requires the use of TLS.
	TokenUrl string
	// The URL to be used for obtaining refresh tokens. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS.
	RefreshUrl string
	// The available scopes for the OAuth2 security scheme. A map between the
	// scope name and a short description for it. The map MAY be empty.
	Scopes map[string]string
}

func (v *ClientCredentialsOAuthFlow) toProto() *pb.ClientCredentialsOAuthFlow {
	if v == nil {
		return nil
	}
	return &pb.ClientCredentialsOAuthFlow{
		TokenUrl:   v.TokenUrl,
		RefreshUrl: v.RefreshUrl,
		Scopes:     v.Scopes,
	}
}

func (ClientCredentialsOAuthFlow) fromProto(p *pb.ClientCredentialsOAuthFlow) *ClientCredentialsOAuthFlow {
	if p == nil {
		return nil
	}
	return &ClientCredentialsOAuthFlow{
		TokenUrl:   p.TokenUrl,
		RefreshUrl: p.RefreshUrl,
		Scopes:     p.Scopes,
	}
}

// DataPart represents a structured blob. This is most commonly a JSON payload.
type DataPart struct {
	Data map[string]any
}

func (v *DataPart) toProto() *pb.DataPart {
	if v == nil {
		return nil
	}
	return &pb.DataPart{
		Data: pvMapToStructPB(v.Data),
	}
}

func (DataPart) fromProto(p *pb.DataPart) *DataPart {
	if p == nil {
		return nil
	}
	return &DataPart{
		Data: pvMapFromStructPB(p.Data),
	}
}

// FilePart represents the different ways files can be provided. If files are
// small, directly feeding the bytes is supported via file_with_bytes. If the
// file is large, the agent should read the content as appropriate directly
// from the file_with_uri source.
type FilePart struct {
	// Types that are valid to be assigned to File:
	//
	//	*FilePart_FileWithUri
	//	*FilePart_FileWithBytes
	File     *FilePartData
	MIMEType string
}

func (v *FilePart) toProto() *pb.FilePart {
	if v == nil {
		return nil
	}
	p := &pb.FilePart{
		MimeType: v.MIMEType,
	}
	populateFilePartTo(p, v)
	return p
}

func (FilePart) fromProto(p *pb.FilePart) *FilePart {
	if p == nil {
		return nil
	}
	v := &FilePart{
		MIMEType: p.MimeType,
	}
	populateFilePartFrom(v, p)
	return v
}

type HTTPAuthSecurityScheme struct {
	// Description of this security scheme.
	Description string
	// The name of the HTTP Authentication scheme to be used in the
	// Authorization header as defined in RFC7235. The values used SHOULD be
	// registered in the IANA Authentication Scheme registry.
	// The value is case-insensitive, as defined in RFC7235.
	Scheme string
	// A hint to the client to identify how the bearer token is formatted.
	// Bearer tokens are usually generated by an authorization server, so
	// this information is primarily for documentation purposes.
	BearerFormat string
}

func (v *HTTPAuthSecurityScheme) toProto() *pb.HTTPAuthSecurityScheme {
	if v == nil {
		return nil
	}
	return &pb.HTTPAuthSecurityScheme{
		Description:  v.Description,
		Scheme:       v.Scheme,
		BearerFormat: v.BearerFormat,
	}
}

func (HTTPAuthSecurityScheme) fromProto(p *pb.HTTPAuthSecurityScheme) *HTTPAuthSecurityScheme {
	if p == nil {
		return nil
	}
	return &HTTPAuthSecurityScheme{
		Description:  p.Description,
		Scheme:       p.Scheme,
		BearerFormat: p.BearerFormat,
	}
}

type ImplicitOAuthFlow struct {
	// The authorization URL to be used for this flow. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS
	AuthorizationUrl string
	// The URL to be used for obtaining refresh tokens. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS.
	RefreshUrl string
	// The available scopes for the OAuth2 security scheme. A map between the
	// scope name and a short description for it. The map MAY be empty.
	Scopes map[string]string
}

func (v *ImplicitOAuthFlow) toProto() *pb.ImplicitOAuthFlow {
	if v == nil {
		return nil
	}
	return &pb.ImplicitOAuthFlow{
		AuthorizationUrl: v.AuthorizationUrl,
		RefreshUrl:       v.RefreshUrl,
		Scopes:           v.Scopes,
	}
}

func (ImplicitOAuthFlow) fromProto(p *pb.ImplicitOAuthFlow) *ImplicitOAuthFlow {
	if p == nil {
		return nil
	}
	return &ImplicitOAuthFlow{
		AuthorizationUrl: p.AuthorizationUrl,
		RefreshUrl:       p.RefreshUrl,
		Scopes:           p.Scopes,
	}
}

type ListTaskPushNotificationConfigResponse struct {
	Configs []*TaskPushNotificationConfig
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken string
}

func (v *ListTaskPushNotificationConfigResponse) toProto() *pb.ListTaskPushNotificationConfigResponse {
	if v == nil {
		return nil
	}
	return &pb.ListTaskPushNotificationConfigResponse{
		Configs:       pvTransformSlice(v.Configs, (*TaskPushNotificationConfig).toProto),
		NextPageToken: v.NextPageToken,
	}
}

func (ListTaskPushNotificationConfigResponse) fromProto(p *pb.ListTaskPushNotificationConfigResponse) *ListTaskPushNotificationConfigResponse {
	if p == nil {
		return nil
	}
	return &ListTaskPushNotificationConfigResponse{
		Configs:       pvTransformSlice(p.Configs, (TaskPushNotificationConfig{}).fromProto),
		NextPageToken: p.NextPageToken,
	}
}

// Message is one unit of communication between client and server. It is
// associated with a context and optionally a task. Since the server is
// responsible for the context definition, it must always provide a context_id
// in its messages. The client can optionally provide the context_id if it
// knows the context to associate the message to. Similarly for task_id,
// except the server decides if a task is created and whether to include the
// task_id.
type Message struct {
	// The message id of the message. This is required and created by the
	// message creator.
	MessageId string
	// The context id of the message. This is optional and if set, the message
	// will be associated with the given context.
	ContextId string
	// The task id of the message. This is optional and if set, the message
	// will be associated with the given task.
	TaskId string
	// A role for the message.
	Role Role
	// Content is the container of the message content.
	Content []Part
	// Any optional metadata to provide along with the message.
	Metadata map[string]any
	// The URIs of extensions that are present or contributed to this Message.
	Extensions []string
}

func (v *Message) toProto() *pb.Message {
	if v == nil {
		return nil
	}
	return &pb.Message{
		MessageId:  v.MessageId,
		ContextId:  v.ContextId,
		TaskId:     v.TaskId,
		Role:       pb.Role(v.Role),
		Content:    pvTransformSlice(v.Content, partToProto),
		Metadata:   pvMapToStructPB(v.Metadata),
		Extensions: v.Extensions,
	}
}

func (Message) fromProto(p *pb.Message) *Message {
	if p == nil {
		return nil
	}
	return &Message{
		MessageId:  p.MessageId,
		ContextId:  p.ContextId,
		TaskId:     p.TaskId,
		Role:       Role(p.Role),
		Content:    pvTransformSlice(p.Content, partFromProto),
		Metadata:   pvMapFromStructPB(p.Metadata),
		Extensions: p.Extensions,
	}
}

type OAuth2SecurityScheme struct {
	// Description of this security scheme.
	Description string
	// An object containing configuration information for the flow types supported
	Flows OAuthFlows
}

func (v *OAuth2SecurityScheme) toProto() *pb.OAuth2SecurityScheme {
	if v == nil {
		return nil
	}
	return &pb.OAuth2SecurityScheme{
		Description: v.Description,
		Flows:       oAuthFlowsToProto(v.Flows),
	}
}

func (OAuth2SecurityScheme) fromProto(p *pb.OAuth2SecurityScheme) *OAuth2SecurityScheme {
	if p == nil {
		return nil
	}
	return &OAuth2SecurityScheme{
		Description: p.Description,
		Flows:       oAuthFlowsFromProto(p.Flows),
	}
}

type OpenIdConnectSecurityScheme struct {
	// Description of this security scheme.
	Description string
	// Well-known URL to discover the [[OpenID-Connect-Discovery]] provider
	// metadata.
	OpenIdConnectUrl string
}

func (v *OpenIdConnectSecurityScheme) toProto() *pb.OpenIdConnectSecurityScheme {
	if v == nil {
		return nil
	}
	return &pb.OpenIdConnectSecurityScheme{
		Description:      v.Description,
		OpenIdConnectUrl: v.OpenIdConnectUrl,
	}
}

func (OpenIdConnectSecurityScheme) fromProto(p *pb.OpenIdConnectSecurityScheme) *OpenIdConnectSecurityScheme {
	if p == nil {
		return nil
	}
	return &OpenIdConnectSecurityScheme{
		Description:      p.Description,
		OpenIdConnectUrl: p.OpenIdConnectUrl,
	}
}

type PasswordOAuthFlow struct {
	// The token URL to be used for this flow. This MUST be in the form of a URL.
	// The OAuth2 standard requires the use of TLS.
	TokenUrl string
	// The URL to be used for obtaining refresh tokens. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS.
	RefreshUrl string
	// The available scopes for the OAuth2 security scheme. A map between the
	// scope name and a short description for it. The map MAY be empty.
	Scopes map[string]string
}

func (v *PasswordOAuthFlow) toProto() *pb.PasswordOAuthFlow {
	if v == nil {
		return nil
	}
	return &pb.PasswordOAuthFlow{
		TokenUrl:   v.TokenUrl,
		RefreshUrl: v.RefreshUrl,
		Scopes:     v.Scopes,
	}
}

func (PasswordOAuthFlow) fromProto(p *pb.PasswordOAuthFlow) *PasswordOAuthFlow {
	if p == nil {
		return nil
	}
	return &PasswordOAuthFlow{
		TokenUrl:   p.TokenUrl,
		RefreshUrl: p.RefreshUrl,
		Scopes:     p.Scopes,
	}
}

// PushNotificationConfig is configuration for setting up push notifications for task updates.
type PushNotificationConfig struct {
	// A unique id for this push notification.
	Id string
	// Url to send the notification too
	Url string
	// Token unique for this task/session
	Token string
	// Information about the authentication to sent with the notification
	Authentication *AuthenticationInfo
}

func (v *PushNotificationConfig) toProto() *pb.PushNotificationConfig {
	if v == nil {
		return nil
	}
	return &pb.PushNotificationConfig{
		Id:             v.Id,
		Url:            v.Url,
		Token:          v.Token,
		Authentication: v.Authentication.toProto(),
	}
}

func (PushNotificationConfig) fromProto(p *pb.PushNotificationConfig) *PushNotificationConfig {
	if p == nil {
		return nil
	}
	return &PushNotificationConfig{
		Id:             p.Id,
		Url:            p.Url,
		Token:          p.Token,
		Authentication: (AuthenticationInfo{}).fromProto(p.Authentication),
	}
}

type Role int32

const (
	RoleUnspecified Role = 0
	// RoleUser means USER role refers to communication from the client to the server.
	RoleUser Role = 1
	// RoleAgent means AGENT role refers to communication from the server to the client.
	RoleAgent Role = 2
)

var namesForRole = map[Role]string{
	RoleUnspecified: "RoleUnspecified",
	RoleUser:        "RoleUser",
	RoleAgent:       "RoleAgent",
}

func (v Role) String() string {
	if n, ok := namesForRole[v]; ok {
		return n
	}
	return fmt.Sprintf("Role(%d)", v)
}

type Security struct {
	Schemes map[string]*StringList
}

func (v *Security) toProto() *pb.Security {
	if v == nil {
		return nil
	}
	return &pb.Security{
		Schemes: pvTransformMapValues(v.Schemes, (*StringList).toProto),
	}
}

func (Security) fromProto(p *pb.Security) *Security {
	if p == nil {
		return nil
	}
	return &Security{
		Schemes: pvTransformMapValues(p.Schemes, (StringList{}).fromProto),
	}
}

// SendMessageConfiguration is configuration of a send message request.
type SendMessageConfiguration struct {
	// The output modes that the agent is expected to respond with.
	AcceptedOutputModes []string
	// A configuration of a webhook that can be used to receive updates
	PushNotification *PushNotificationConfig
	// The maximum number of messages to include in the history. if 0, the
	// history will be unlimited.
	HistoryLength int32
	// If true, the message will be blocking until the task is completed. If
	// false, the message will be non-blocking and the task will be returned
	// immediately. It is the caller's responsibility to check for any task
	// updates.
	Blocking bool
}

func (v *SendMessageConfiguration) toProto() *pb.SendMessageConfiguration {
	if v == nil {
		return nil
	}
	return &pb.SendMessageConfiguration{
		AcceptedOutputModes: v.AcceptedOutputModes,
		PushNotification:    v.PushNotification.toProto(),
		HistoryLength:       v.HistoryLength,
		Blocking:            v.Blocking,
	}
}

func (SendMessageConfiguration) fromProto(p *pb.SendMessageConfiguration) *SendMessageConfiguration {
	if p == nil {
		return nil
	}
	return &SendMessageConfiguration{
		AcceptedOutputModes: p.AcceptedOutputModes,
		PushNotification:    (PushNotificationConfig{}).fromProto(p.PushNotification),
		HistoryLength:       p.HistoryLength,
		Blocking:            p.Blocking,
	}
}

type SendMessageResponse struct {
	// Types that are valid to be assigned to Payload:
	//
	//	*SendMessageResponse_Task
	//	*SendMessageResponse_Msg
	Payload *MessageResponsePayload
}

func (v *SendMessageResponse) toProto() *pb.SendMessageResponse {
	if v == nil {
		return nil
	}
	p := &pb.SendMessageResponse{}
	populateMessageResponseTo(p, v)
	return p
}

func (SendMessageResponse) fromProto(p *pb.SendMessageResponse) *SendMessageResponse {
	if p == nil {
		return nil
	}
	v := &SendMessageResponse{}
	populateMessageResponseFrom(v, p)
	return v
}

// StreamResponse is the stream response for a message. The stream should be one of the following
// sequences:
// If the response is a message, the stream should contain one, and only one,
// message and then close
// If the response is a task lifecycle, the first response should be a Task
// object followed by zero or more TaskStatusUpdateEvents and
// TaskArtifactUpdateEvents. The stream should complete when the Task
// if in an interrupted or terminal state. A stream that ends before these
// conditions are met are
type StreamResponse struct {
	// Types that are valid to be assigned to Payload:
	//
	//	*StreamResponse_Task
	//	*StreamResponse_Msg
	//	*StreamResponse_StatusUpdate
	//	*StreamResponse_ArtifactUpdate
	Payload *StreamResponsePayload
}

func (v *StreamResponse) toProto() *pb.StreamResponse {
	if v == nil {
		return nil
	}
	p := &pb.StreamResponse{}
	populateStreamResponseTo(p, v)
	return p
}

func (StreamResponse) fromProto(p *pb.StreamResponse) *StreamResponse {
	if p == nil {
		return nil
	}
	v := &StreamResponse{}
	populateStreamResponseFrom(v, p)
	return v
}

type StringList struct {
	List []string
}

func (v *StringList) toProto() *pb.StringList {
	if v == nil {
		return nil
	}
	return &pb.StringList{
		List: v.List,
	}
}

func (StringList) fromProto(p *pb.StringList) *StringList {
	if p == nil {
		return nil
	}
	return &StringList{
		List: p.List,
	}
}

// Task is the core unit of action for A2A. It has a current status
// and when results are created for the task they are stored in the
// artifact. If there are multiple turns for a task, these are stored in
// history.
type Task struct {
	// Unique identifier for a task, created by the A2A server.
	Id string
	// Unique identifier for the contextual collection of interactions (tasks
	// and messages). Created by the A2A server.
	ContextId string
	// The current status of a Task, including state and a message.
	Status *TaskStatus
	// A set of output artifacts for a Task.
	Artifacts []*Artifact
	// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
	// The history of interactions from a task.
	History []*Message
	// protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
	// A key/value object to store custom metadata about a task.
	Metadata map[string]any
}

func (v *Task) toProto() *pb.Task {
	if v == nil {
		return nil
	}
	return &pb.Task{
		Id:        v.Id,
		ContextId: v.ContextId,
		Status:    v.Status.toProto(),
		Artifacts: pvTransformSlice(v.Artifacts, (*Artifact).toProto),
		History:   pvTransformSlice(v.History, (*Message).toProto),
		Metadata:  pvMapToStructPB(v.Metadata),
	}
}

func (Task) fromProto(p *pb.Task) *Task {
	if p == nil {
		return nil
	}
	return &Task{
		Id:        p.Id,
		ContextId: p.ContextId,
		Status:    (TaskStatus{}).fromProto(p.Status),
		Artifacts: pvTransformSlice(p.Artifacts, (Artifact{}).fromProto),
		History:   pvTransformSlice(p.History, (Message{}).fromProto),
		Metadata:  pvMapFromStructPB(p.Metadata),
	}
}

// TaskArtifactUpdateEvent represents a task delta where an artifact has
// been generated.
type TaskArtifactUpdateEvent struct {
	// The id of the task for this artifact
	TaskId string
	// The id of the context that this task belongs too
	ContextId string
	// The artifact itself
	Artifact *Artifact
	// Whether this should be appended to a prior one produced
	Append bool
	// Whether this represents the last part of an artifact
	LastChunk bool
	// Optional metadata associated with the artifact update.
	Metadata map[string]any
}

func (v *TaskArtifactUpdateEvent) toProto() *pb.TaskArtifactUpdateEvent {
	if v == nil {
		return nil
	}
	return &pb.TaskArtifactUpdateEvent{
		TaskId:    v.TaskId,
		ContextId: v.ContextId,
		Artifact:  v.Artifact.toProto(),
		Append:    v.Append,
		LastChunk: v.LastChunk,
		Metadata:  pvMapToStructPB(v.Metadata),
	}
}

func (TaskArtifactUpdateEvent) fromProto(p *pb.TaskArtifactUpdateEvent) *TaskArtifactUpdateEvent {
	if p == nil {
		return nil
	}
	return &TaskArtifactUpdateEvent{
		TaskId:    p.TaskId,
		ContextId: p.ContextId,
		Artifact:  (Artifact{}).fromProto(p.Artifact),
		Append:    p.Append,
		LastChunk: p.LastChunk,
		Metadata:  pvMapFromStructPB(p.Metadata),
	}
}

type TaskPushNotificationConfig struct {
	// name=tasks/{id}/pushNotificationConfigs/{id}
	Name                   string
	PushNotificationConfig *PushNotificationConfig
}

func (v *TaskPushNotificationConfig) toProto() *pb.TaskPushNotificationConfig {
	if v == nil {
		return nil
	}
	return &pb.TaskPushNotificationConfig{
		Name:                   v.Name,
		PushNotificationConfig: v.PushNotificationConfig.toProto(),
	}
}

func (TaskPushNotificationConfig) fromProto(p *pb.TaskPushNotificationConfig) *TaskPushNotificationConfig {
	if p == nil {
		return nil
	}
	return &TaskPushNotificationConfig{
		Name:                   p.Name,
		PushNotificationConfig: (PushNotificationConfig{}).fromProto(p.PushNotificationConfig),
	}
}

// TaskState is the set of states a Task can be in.
type TaskState int32

const (
	TaskStateTaskstateTaskStateUnspecified TaskState = 0
	// TaskStateTaskstateTaskStateSubmitted means represents the status that acknowledges a task is created
	TaskStateTaskstateTaskStateSubmitted TaskState = 1
	// TaskStateTaskstateTaskStateWorking means represents the status that a task is actively being processed
	TaskStateTaskstateTaskStateWorking TaskState = 2
	// TaskStateTaskstateTaskStateCompleted means represents the status a task is finished. This is a terminal state
	TaskStateTaskstateTaskStateCompleted TaskState = 3
	// TaskStateTaskstateTaskStateFailed means represents the status a task is done but failed. This is a terminal state
	TaskStateTaskstateTaskStateFailed TaskState = 4
	// TaskStateTaskstateTaskStateCancelled means represents the status a task was cancelled before it finished.
	// This is a terminal state.
	TaskStateTaskstateTaskStateCancelled TaskState = 5
	// TaskStateTaskstateTaskStateInputRequired means represents the status that the task requires information to complete.
	// This is an interrupted state.
	TaskStateTaskstateTaskStateInputRequired TaskState = 6
	// TaskStateTaskstateTaskStateRejected means represents the status that the agent has decided to not perform the task.
	// This may be done during initial task creation or later once an agent
	// has determined it can't or won't proceed. This is a terminal state.
	TaskStateTaskstateTaskStateRejected TaskState = 7
	// TaskStateTaskstateTaskStateAuthRequired means represents the state that some authentication is needed from the upstream
	// client. Authentication is expected to come out-of-band thus this is not
	// an interrupted or terminal state.
	TaskStateTaskstateTaskStateAuthRequired TaskState = 8
)

var namesForTaskState = map[TaskState]string{
	TaskStateTaskstateTaskStateUnspecified:   "TaskStateTaskstateTaskStateUnspecified",
	TaskStateTaskstateTaskStateSubmitted:     "TaskStateTaskstateTaskStateSubmitted",
	TaskStateTaskstateTaskStateWorking:       "TaskStateTaskstateTaskStateWorking",
	TaskStateTaskstateTaskStateCompleted:     "TaskStateTaskstateTaskStateCompleted",
	TaskStateTaskstateTaskStateFailed:        "TaskStateTaskstateTaskStateFailed",
	TaskStateTaskstateTaskStateCancelled:     "TaskStateTaskstateTaskStateCancelled",
	TaskStateTaskstateTaskStateInputRequired: "TaskStateTaskstateTaskStateInputRequired",
	TaskStateTaskstateTaskStateRejected:      "TaskStateTaskstateTaskStateRejected",
	TaskStateTaskstateTaskStateAuthRequired:  "TaskStateTaskstateTaskStateAuthRequired",
}

func (v TaskState) String() string {
	if n, ok := namesForTaskState[v]; ok {
		return n
	}
	return fmt.Sprintf("TaskState(%d)", v)
}

// TaskStatus is a container for the status of a task
type TaskStatus struct {
	// The current state of this task
	State TaskState
	// A message associated with the status.
	Update *Message
	// Timestamp when the status was recorded.
	// Example: "2023-10-27T10:00:00Z"
	Timestamp time.Time
}

func (v *TaskStatus) toProto() *pb.TaskStatus {
	if v == nil {
		return nil
	}
	return &pb.TaskStatus{
		State:     pb.TaskState(v.State),
		Update:    v.Update.toProto(),
		Timestamp: pvTimeToProto(v.Timestamp),
	}
}

func (TaskStatus) fromProto(p *pb.TaskStatus) *TaskStatus {
	if p == nil {
		return nil
	}
	return &TaskStatus{
		State:     TaskState(p.State),
		Update:    (Message{}).fromProto(p.Update),
		Timestamp: pvTimeFromProto(p.Timestamp),
	}
}

// TaskStatusUpdateEvent is a delta even on a task indicating that a task
// has changed.
type TaskStatusUpdateEvent struct {
	// The id of the task that is changed
	TaskId string
	// The id of the context that the task belongs to
	ContextId string
	// The new status of the task.
	Status *TaskStatus
	// Whether this is the last status update expected for this task.
	Final bool
	// Optional metadata to associate with the task update.
	Metadata map[string]any
}

func (v *TaskStatusUpdateEvent) toProto() *pb.TaskStatusUpdateEvent {
	if v == nil {
		return nil
	}
	return &pb.TaskStatusUpdateEvent{
		TaskId:    v.TaskId,
		ContextId: v.ContextId,
		Status:    v.Status.toProto(),
		Final:     v.Final,
		Metadata:  pvMapToStructPB(v.Metadata),
	}
}

func (TaskStatusUpdateEvent) fromProto(p *pb.TaskStatusUpdateEvent) *TaskStatusUpdateEvent {
	if p == nil {
		return nil
	}
	return &TaskStatusUpdateEvent{
		TaskId:    p.TaskId,
		ContextId: p.ContextId,
		Status:    (TaskStatus{}).fromProto(p.Status),
		Final:     p.Final,
		Metadata:  pvMapFromStructPB(p.Metadata),
	}
}

// pvTransformSlice applies f to each element of from and returns
// a new slice with the results.
func pvTransformSlice[From, To any](from []From, f func(From) To) []To {
	if from == nil {
		return nil
	}
	to := make([]To, len(from))
	for i, e := range from {
		to[i] = f(e)
	}
	return to
}

// pvTransformMapValues applies f to each value of from, returning a new map.
// It does not change the keys.
func pvTransformMapValues[K comparable, VFrom, VTo any](from map[K]VFrom, f func(VFrom) VTo) map[K]VTo {
	if from == nil {
		return nil
	}
	to := map[K]VTo{}
	for k, v := range from {
		to[k] = f(v)
	}
	return to
}

// pvMapToStructPB converts a map into a structpb.Struct.
func pvMapToStructPB(m map[string]any) *structpb.Struct {
	if m == nil {
		return nil
	}
	s, err := structpb.NewStruct(m)
	if err != nil {
		panic(pvPanic(fmt.Errorf("pvMapToStructPB: %w", err)))
	}
	return s
}

// pvMapFromStructPB converts a structpb.Struct to a map.
func pvMapFromStructPB(p *structpb.Struct) map[string]any {
	if p == nil {
		return nil
	}
	return p.AsMap()
}

// pvTimeToProto converts a time.Time into a Timestamp.
func pvTimeToProto(t time.Time) *timestamppb.Timestamp {
	if t.IsZero() {
		return nil
	}
	return timestamppb.New(t)
}

// pvTimeFromProto converts a Timestamp into a time.Time.
func pvTimeFromProto(ts *timestamppb.Timestamp) time.Time {
	if ts == nil {
		return time.Time{}
	}
	return ts.AsTime()
}

// pvPanic wraps panics from support functions.
// User-provided functions in the same package can also use it.
// It allows callers to distinguish conversion function panics from other panics.
type pvPanic error

// pvCatchPanic recovers from panics of type pvPanic and
// returns an error instead.
func pvCatchPanic[T any](f func() T) (_ T, err error) {
	defer func() {
		if r := recover(); r != nil {
			if _, ok := r.(pvPanic); ok {
				err = r.(error)
			} else {
				panic(r)
			}
		}
	}()
	return f(), nil
}
